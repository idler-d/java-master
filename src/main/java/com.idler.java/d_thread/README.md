# 线程体系的记忆

  首先先建立一个认知，线程的启动必须通过start方法来启动（至少在非线程池情况下），
  所以需要建立一个线程，一般都必须创建Thread类，然后调用start方法来启动。
  （注：先抛开线程池的实现。单纯从建立一个线程的流程去展开。）
  
  然后建立一套流程。
  1. 创建一个新的任务，就是说需要实现了run方法的Runnable类。
  2. 创建一个新的Thread类，就是告诉JVM创建一个线程，然后把任务交给线程。
  3. 调用Thread的start方法，告诉JVM线程开始调配资源开始运行线程任务。
  
  然后是任务的认知。一种是带返回值的任务和另外一种不带返回值的任务。
  1. 带返回值的任务，在这总结之前我对线程的体系还是比较混乱的，
     分不清楚怎么建立带返回值和不带返回值。  
     首先根据线程流程的认知。  
     其实Thread是在线程开始去调用Runnable的run方法的。
     但是带返回值的任务是继承于Callable类。Callable类的调用时Call方法。  
     所以Thread类是不接受Callable类的。所以如果启动一个带返回值的线程，
     就需要有一个中转的过程，这是就需要到FutureTask类，
     FutureTask类是继承于Runnable类的，这样Thread类就会接受这个带有Runnable实现的类。
     从而实现有返回值任务的线程。
  
  2. 不带返回值的任务，就是实现Runnable类任务，把任务交给Thread就可以。
     简单来说就是线程建立流程。
  
  然后是线程状态的认知（根据深入java虚拟机）。  
  线程装备的认知先从主流程开始，然后加入一些分支调用状态。  
  
  1. 新建（New）： 创建后尚未启动的线程。
  2. 运行（Runnable）： Runnable包括running和ready状态。
  3. 结束（Terminated）： 已终止线程的线程状态。
  上述3个为线程正常运行的流程，下面增加分支。
  4. 无限期等待（Waiting）： 处于这种状态不会被分配CPU执行时间，
     它们要等待其他线程显式地唤醒。  
     - 没有设置Timeout参数的Object.wait()方法。
     - 没有设置Timeout参数的Thread.join()方法。
     - LockSupport.park()方法。
  5. 限期等待（Time Waiting）： 处于这种状态也不会被分配CPU执行时间，
      不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。
     - Thread.sleep()方法
     - 设置了Timeout参数的Object.wait()方法。
     - 设置了Timeout参数的Thread.join()方法。
     - LockSupport.parkNanos()方法。
     - LockSupport.parkUnit()方法。
  6. 阻塞（Blocked）： 线程被阻塞了，“阻塞状态” 与 “等待状态”的区别是：
     “阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生，
     而“等待状态”则是在等待一段时间，或者唤醒动作的时候发生。在程序等待进入同步区域的时候，
     线程将进入这个状态。
     
  然后是线程中断相关的认知。
  首先线程本身带有Thread.interrupt()方法。根据函数的名称可以认知是中断线程的方法。
  但是这里有个陷阱，就是interrupt方法并不会中断一个运行中的线程。简单来说就是：
  一个正在正常流程上（处于running）的线程是不会受到interrupt方法的影响的。
  所以一般需要做中断处理线程的操作需要两个部分的支持：
  
  1. 设定退出变量： 就是说运行中的任务在运行过程中需要做变量的判定，在变量改变时就退出任务。
  2. 调用Thread.interrupt()方法：就是把不处于运行中的任务做中断处理，在一个不再运行中的任务就不会运行代码，
     就没有办法判断退出变量。所以这是需要调用线程的interrupt方法来中断线程。